<!DOCTYPE html>
<html lang="en">
    <head>
	<title>Cole Faust - HW1 Part C</title>
	<meta charset="utf-8">
	<style>
	 body {
	     margin: 0px;
	     overflow: hidden;
	 }
	</style>
    </head>
    <body>
        <div style="width: 100%; height: 50px; overflow: scroll">
            <span style="display: inline-block;">Neighbor threshold (<span id="thresholdSliderOutput">3</span>): <input type="range" min="0" max="10" value="3" id="thresholdSlider"/></span>
            <span style="display: inline-block;">Neighbor distance (<span id="maxStatesOutput">1</span>): <input type="range" min="0" max="10" value="1" id="maxStatesSlider"/></span>
            <span style="display: inline-block;">Number of States (<span id="maxStatesOutput">3</span>): <input type="range" min="2" max="10" value="3" id="maxStatesSlider"/></span>
            
        </div>
        <div id="container"></div>
        <script src="../three.js"></script>

        <script id="vertexShader" type="x-shader/x-vertex">
	 uniform mat4 modelViewMatrix;
      	 uniform mat4 projectionMatrix;

	 attribute vec3 position;
         attribute vec2 uv;

         varying vec2 vUV;
	 
    	 void main() {
             vUV = uv;
 	     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
	 }
        </script>

        <script id="fragmentShader" type="x-shader/x-fragment">
	 precision mediump float;

	 uniform vec2 textureSize; //The width and height of our screen
	 uniform sampler2D bufferTexture; //Our input texture
         uniform float threshold;
         uniform float distance;
         uniform float distanceType;
         uniform float maxStates;

         varying vec2 vUV;
         
	 void main() {
	     float cx = vUV.x;
	     float cy = vUV.y;

             vec4 C = texture2D( bufferTexture, vec2( cx, cy ) );
             
	     float left = cx - 1.0/textureSize.x;
	     if (left < 0.0) { left = 1.0; }
	     float right = cx + 1.0/textureSize.x;
	     if (left > 1.0) { left = 0.0; }

	     float down = cy - 1.0/textureSize.y;
	     if (down < 0.0) { down = 1.0; }
	     float up = cy + 1.0/textureSize.y;
	     if (up > 1.0) { up = 0.0; }

	     vec4 arr[8];

	     arr[0] = texture2D( bufferTexture, vec2( cx   , up ));   //N
	     arr[1] = texture2D( bufferTexture, vec2( right, up ));   //NE
	     arr[2] = texture2D( bufferTexture, vec2( right, cy ));   //E
	     arr[3] = texture2D( bufferTexture, vec2( right, down )); //SE
	     arr[4] = texture2D( bufferTexture, vec2( cx   , down )); //S
	     arr[5] = texture2D( bufferTexture, vec2( left , down )); //SW
	     arr[6] = texture2D( bufferTexture, vec2( left , cy ));   //W
	     arr[7] = texture2D( bufferTexture, vec2( left , up ));   //NW

	     int cnt = 0;
	     for(int i=0;i<8;i++){
                 // if this is the highest state, rollover to checking for 0
                 if(C.r >= 1.0 - (3.0/2.0)*(1.0/maxStates)) {
                     if(arr[i].r <= (1.0/maxStates/2.0)) {
                         cnt++;
                     }
                 } else {
		     if (arr[i].r >= C.r + (1.0/maxStates/2.0) &&
                         arr[i].r <= C.r + (3.0/2.0)*(1.0/maxStates)) {
		         cnt++;
		     }
                 }
	     }

             if(float(cnt) >= threshold) {
                 float newVal = C.r + (1.0/maxStates);
                 if(newVal >= 1.0 - (1.0/maxStates/2.0)) {
                     newVal = 0.0;
                 }
                 gl_FragColor = vec4(newVal, newVal, newVal, 1.0);
             } else {
                 gl_FragColor = C;
             }
	 }
	</script>
	<script>
         var scene = new THREE.Scene();
         var camera;
         var renderer = new THREE.WebGLRenderer();

         var resX = 300;
         var resY = 300;

         var bufferScene = new THREE.Scene();
         var bufferMaterial;
         var bufferObject;
         var FBO_A, FBO_B;
         var plane;
         var fullScreenQuad;

         var threshold = 3;
         var distance = 1;
         var distanceType = 0;
         var maxStates = 3;
         window.addEventListener( 'resize', onWindowResize, false );
         setup();

         function setup() {
             //orthographic camera can be used for 2D
             camera = new THREE.OrthographicCamera( -resX/2, resX/2, resY/2, -resY/2, 0.1, 1000 );
	     camera.position.z = 0.2;

	     renderer.setSize( window.innerWidth, window.innerHeight - 50 );
	     document.body.appendChild( renderer.domElement );
             
	     //Create 2 buffer textures
	     FBO_A = new THREE.WebGLRenderTarget( resX, resY, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter});
	     FBO_B = new THREE.WebGLRenderTarget( resX, resY, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter});
	     
	     //Begin by passing an initial "seed" texture to shader, containing randomly placed cells
	     var dataTexture = createDataTexture();

	     bufferMaterial = new THREE.RawShaderMaterial({
		 uniforms: {
		     bufferTexture: { type: "t", value: dataTexture },
		     textureSize: {type: "v2", value: new THREE.Vector2( resX, resY )},  //shader doesn't have access to these global variables, so pass in the resolution
                     threshold: {type: 'f', value: threshold},
                     distance: {type: 'f', value: distance},
                     distanceType: {type: 'f', value: distanceType},
                     maxStates: {type: 'f', value: maxStates}
		 },
		 vertexShader: document.getElementById( 'vertexShader' ).innerHTML,
		 fragmentShader: document.getElementById( 'fragmentShader' ).innerHTML
	     } );

	     //we can use a Three.js Plane Geometry along with the orthographic camera to create a "full screen quad"
	     plane = new THREE.PlaneBufferGeometry( resX, resY )

	     bufferObject = new THREE.Mesh( plane, bufferMaterial );
	     bufferScene.add(bufferObject);

	     //Draw textureB to screen 
	     fullScreenQuad = new THREE.Mesh( plane, new THREE.MeshBasicMaterial() );
	     scene.add(fullScreenQuad);
         }

         render();
         function render() {
	     requestAnimationFrame( render );
	     console.log("render");
	     //Draw to the active offscreen buffer (whatever is stored in FBO_B), that is the output of this rendering pass will be stored in the texture associated with FBO_B
	     renderer.render(bufferScene, camera, FBO_B);
	     
	     //grab that texture and map it to the full screen quad
	     fullScreenQuad.material.map = FBO_B.texture;

	     //Then draw the full sceen quad to the on screen buffer, ie, the display
	     renderer.render( scene, camera );


	     //Now prepare for the next cycle by swapping FBO_A and FBO_B, so that the previous frame's *output* becomes the next frame's *input*
	     var t = FBO_A;
	     FBO_A = FBO_B;
	     FBO_B = t;
	     bufferMaterial.uniforms.bufferTexture.value = FBO_A.texture;
         }

         function createDataTexture() {
	     // create a buffer with color data
	     var size = resX * resY;
	     var data = new Uint8Array( 4 * size );

	     for ( var i = 0; i < size; i++ ) {
		 var stride = i * 4;

                 var state = Math.floor(Math.floor(Math.random()*maxStates) * 255 / maxStates);
                 data[stride] = state;
                 data[stride+1] = state;
                 data[stride+2] = state;
                 data[stride+3] = 255;
	     }

	     // used the buffer to create a DataTexture
	     console.log(data);
	     var texture = new THREE.DataTexture( data, resX, resY, THREE.RGBAFormat );	     
	     texture.needsUpdate = true; // just a weird thing that Three.js wants you to do after you set the data for the texture
	     return texture;
         }
         function onWindowResize() {
             renderer.setSize( window.innerWidth, window.innerHeight-50 );
         }
	</script>
    </body>
</html>

